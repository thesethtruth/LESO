import pandas as pd
from pvlib import irradiance
import numpy as np
from datetime import datetime
import sys

# Single transpose
def transpose_POA(site_location, times, tilt, azimuth, pvgis):
    # generate times
    # Get solar azimuth and zenith to pass to the transposition function
    solar_position = site_location.get_solarposition(times=times)
    # Use get_total_irradiance to transpose, based on solar position
    POA_irradiance = irradiance.get_total_irradiance(
        surface_tilt=tilt,
        surface_azimuth=azimuth,
        dni=pvgis["Gb(n)"],
        ghi=pvgis["G(h)"],
        dhi=pvgis["Gd(h)"],
        solar_zenith=solar_position['apparent_zenith'],
        solar_azimuth=solar_position['azimuth'])
    # Return DataFrame
    return pd.DataFrame({'GHI': pvgis["G(h)"],
                         'POA': POA_irradiance['poa_global']}) 


def PVf(site, start_future, PV, pvgis_dataset_location):
    # Create custom date parser
    from datetime import datetime
    dateparse = lambda x: datetime.strptime(x, '%Y%m%d:%H%M%S')
    # TMY data from PV GIS (C) https://re.jrc.ec.europa.eu/pvg_tools/en/#TMY
    pvgis = pd.read_csv("data/centralNL.csv",
                            nrows=8760,skiprows=16,
                            usecols=[i for i in range (11) if i >-1 and i < 10],
                            parse_dates=['time(UTC)'],
                            date_parser=dateparse)
    # Remember, PV GIS (C) defines the folowing:
    # G(h): Global irradiance on the horizontal plane (W/m2)                        === GHI 
    # Gb(n): Beam/direct irradiance on a plane always normal to sun rays (W/m2)     === DNI
    # Gd(h): Diffuse irradiance on the horizontal plane (W/m2)                      === DHI
    
    # Write the timestamps from the TMY to a seperate frame to use in transposition
    times = pvgis['time(UTC)']
    # Set the PV GIS (C) indices to comply with the time and drop the time column
    pvgis.index = times
    pvgis.drop('time(UTC)', axis = 'columns', inplace = True)
    # Convert GHI to POA using pvlib
    # Send data to transpotition function and return irradiance in Plane of Angle (POA)
    pvgis_POA = transpose_POA(site, times, PV.tilt, PV.azimuth, pvgis)
    # Reset the indices to future year 2021, such that we can manipulate the dfs together
    pvgis_POA.index = pd.date_range(start_future, periods=8760, freq="1h")
    # Generate the power
    PV.power = pvgis_POA["POA"]   * PV.efficiency * PV.area
    # Yearly energy generated
    PV.yearly = PV.power.sum()
    PV.weekly = PV.power.groupby(Weeks()).sum()
    return PV

def Windf(start_future, wind, wind_dataset_location):
    installed_wind_ref = 90*1e3                          # Current refference for wind power (should change!)
    specific_wind = 272381760.0 / installed_wind_ref     # Specific energy yield per w of installed power (should change!)
    wind.yearly = specific_wind * wind.installed  # Converting the installed capacity to yearly energy based on the specific energy yield (estimate and should change!)
    # Read the WIND data
    temp_wind = pd.read_csv(wind_dataset_location,nrows=35040,skiprows=0,usecols=[2,3])
    temp_wind.columns = ["Wind speed", "Power"]
    # Convert KW to W
    temp_wind["Power"] = temp_wind["Power"]*1e3
    # Sum the data from every 15 mins to 1 hour
    wind.power = temp_wind["Power"].groupby(temp_wind.index // 4).mean()
    wind.speed = temp_wind["Wind speed"].groupby(temp_wind.index // 4).mean()
    # Set the dates 
    wind.speed.index = pd.date_range(start_future, periods=8760, freq="1h")
    wind.power.index = pd.date_range(start_future, periods=8760, freq="1h")
    # Set wind power to unity
    wind.power = wind.power/wind.power.sum()
    # Scale wind as 50/50 share according to energy generated by installed PV capacity
    wind.power = wind.power*wind.yearly
    wind.yearly = wind.power.sum()
    wind.weekly = wind.power.groupby(Weeks()).sum()
    return wind

def Consumptionf(start_future, consumption, wind_dataset_location):
    temp_consumption = pd.read_csv(wind_dataset_location,
                         nrows=35040,skiprows=5,usecols=[3])
    temp_consumption.columns = ["Consumption"]
    # Sum the data from every 15 mins to 1 hour
    temp_consumption = temp_consumption["Consumption"].groupby(temp_consumption.index // 4).sum()
    # Set the dates 
    temp_consumption.index = pd.date_range(start_future, periods=8760, freq="1h")
    # Scale the consumption to appropriate size
    consumption.load= -temp_consumption*consumption.scaler
    consumption.yearly = consumption.load.sum()
    consumption.weekly = consumption.load.groupby(Weeks()).sum()
    return consumption

def Weeks():
    indices = np.arange(0,8760)                   # actually 52.17
    weeks = pd.DataFrame(index = indices).index // 168
    weeks = np.where((weeks== 52),51,weeks)
    return weeks

def Balancef(wind, PV, consumption, charger):
    class balance:
        pass
    balance.power = PV.power + wind.power - consumption.load - charger.load
    balance.weekly = PV.weekly + wind.weekly - consumption.weekly - charger.weekly
    # Calculate yearly balance
    balance.yearly = wind.yearly + PV.yearly - consumption.yearly - charger.yearly
    return balance

def BatteryControlf(start_future, balance, battery):
    # This function is messy and should be updated!                                 UPDATE ME!
    # currently it behaves from the perspective of the battery and is later 
    # converted to its inverse for correct power/load behaviour.
    
    # Initiate empty lists and starting SOC
    soc = []
    batcharge = []
    batstat = battery.startingSOC * battery.installed

    for index, value in balance.one.iteritems():
        bal = value

        # charging
        if batstat < battery.installed and bal > 0:
            charge_room = battery.installed - batstat
            if bal >= battery.dischargepower : # over-kill power
                charge = min(battery.dischargepower, charge_room)
            elif bal < battery.dischargepower: # fillable power
                charge = min(bal, charge_room)
            batstat += charge
            
        # discharging
        elif batstat > 0 and bal < 0:
            discharge_room = -batstat
            if bal <= -battery.dischargepower : # over-kill power
                charge = max(-battery.dischargepower, discharge_room)
            elif bal > -battery.dischargepower: # fillable power
                charge = max(bal, discharge_room)
            batstat += charge

        # perfect balance
        else:
            charge = 0
            
        soc.append(batstat)
        batcharge.append(charge)
    
    # ---------- 
    # Store to Data Frames and set times
       
    # SOC
    batterypower = pd.Series(batcharge)
    batterypower.index = pd.date_range(start_future, periods=8760, freq="1h")
    # convert to correct load/power
    battery.load = - batterypower.where(batterypower >=0, 0)
    battery.power = - batterypower.where(batterypower <=0, 0)
    battery.weekly = (battery.power + battery.load).groupby(Weeks()).sum()
    
    # determine sink (storage) values
    battery.sink = pd.Series(soc)
    battery.sink.index = pd.date_range(start_future, periods=8760, freq="1h")
    battery.sink.weekly = battery.sink.groupby(Weeks()).mean()
    
    # and add the SOC as attribute
    battery.sink.SOC = battery.sink / battery.installed
    battery.sink.SOC.weekly = battery.sink.SOC.groupby(Weeks()).mean() 
    
    return battery

def Chargerf(charger, EV, filepath):
    EV.traffic = pd.read_pickle(filepath)
    EV.charge = EV.traffic.where((EV.traffic < charger.installed*charger.carsperhour), charger.installed*charger.carsperhour)
    EV.charge.yearly = EV.charge.sum()
    EV.traffic.yearly = EV.traffic.sum()
    charger.load = -EV.charge * EV.battery / charger.efficiency
    charger.weekly = charger.load.groupby(Weeks()).sum()
    charger.yearly = charger.load.sum()
    return charger, EV

def FinanicalFunction(PV, wind, battery, charger, consumption, grid):
    
    class finance:
        pass
    
    # ----
    # capex breakdown
    wind.capex = wind.installed * wind.cost 
    PV.capex = PV.installed * PV.cost 
    battery.capex = battery.installed * battery.cost 
    charger.capex = charger.installed * charger.cost 
    
    # capex sum
    finance.capex = wind.capex \
            + PV.capex \
            + battery.capex \
            + charger.capex
    
    # ----        
    # opex breakdown
    wind.opex = wind.om * wind.installed
    PV.opex = PV.om * PV.installed
    battery.opex = battery.om * battery.installed
    
    # opex sum
    finance.opex =  wind.opex \
            + PV.opex \
            + battery.opex 
    
    
    # ----
    # income by part
    charger.income = -charger.yearly * charger.price * charger.efficiency
    consumption.income = -consumption.yearly * consumption.price
    grid.income = - grid.load.yearly * grid.price - grid.power.yearly * grid.cost
    
    # income balance
    finance.income = charger.income \
            + consumption.income \
            + grid.income
            
    finance.net_income = finance.income - finance.opex
    finance.IRR = finance.net_income / finance.capex  
    finance.PBY = finance.capex / finance.net_income
    
    
    return finance

